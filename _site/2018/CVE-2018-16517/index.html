<p>The bug is pretty much straightforward and can be triggered with a single line of assembly instruction.</p>

<p>Credit goes to <a href="https://twitter.com/zeifan">@zeifan</a> for discovering this vulnerability by using the AFL fuzzer.</p>

<h1 id="proof-of-crash">Proof-of-Crash</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. echo "equ   push  rax" &gt; poc
2. nasm -f elf poc
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct insn { /* an instruction itself */
    char            *label;                 /* the label defined, or NULL */
    int             prefixes[MAXPREFIX];    /* instruction prefixes, if any */
    enum opcode     opcode;                 /* the opcode - not just the string */
    enum ccode      condition;              /* the condition code, if Jcc/SETcc */
    int             operands;               /* how many operands? 0-3 (more if db et al) */
    int             addr_size;              /* address size */
    operand         oprs[MAX_OPERANDS];     /* the operands, defined as above */
    extop           *eops;                  /* extended operands */
    int             eops_float;             /* true if DD and floating */
    int32_t         times;                  /* repeat count (TIMES prefix) */
    bool            forw_ref;               /* is there a forward reference? */
    bool            rex_done;               /* REX prefix emitted? */
    int             rex;                    /* Special REX Prefix */
    int             vexreg;                 /* Register encoded in VEX prefix */
    int             vex_cm;                 /* Class and M field for VEX prefix */
    int             vex_wlp;                /* W, P and L information for VEX prefix */
    uint8_t         evex_p[3];              /* EVEX.P0: [RXB,R',00,mm], P1: [W,vvvv,1,pp] */
                                            /* EVEX.P2: [z,L'L,b,V',aaa] */
    enum ttypes     evex_tuple;             /* Tuple type for compressed Disp8*N */
    int             evex_rm;                /* static rounding mode for AVX512 (EVEX) */
    int8_t          evex_brerop;            /* BR/ER/SAE operand position */
} insn;
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static void assemble_file(const char *fname, StrList **depend_ptr)
{
    char *line;
    insn output_ins;
    int i;
    uint64_t prev_offset_changed;
    int64_t stall_count = 0; /* Make sure we make forward progress... */

    [...]

        while ((line = preproc-&gt;getline())) {
            if (++globallineno &gt; nasm_limit[LIMIT_LINES])
                nasm_fatal(0,
                           "overall line count exceeds the maximum %"PRId64"\n",
                           nasm_limit[LIMIT_LINES]);

            /*
             * Here we parse our directives; this is not handled by the
             * main parser.
             */
            if (process_directives(line))
                goto end_of_line; /* Just do final cleanup */

            /* Not a directive, or even something that starts with [ */
            parse_line(pass1, line, &amp;output_ins);   &lt;-- [1]

            if (optimizing &gt; 0) {
                if (forwref != NULL &amp;&amp; globallineno == forwref-&gt;lineno) {
                    output_ins.forw_ref = true;
    [...]
</code></pre></div></div>

<p>In assemble_file function, there is an object (output_ins) to a structure (struct insn) which contains the informations regarding the opcode being parsed.
Inside the assemble_file, a function parse_line is called in order initialize the object.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>insn *parse_line(int pass, char *buffer, insn *result)
{
    bool insn_is_label = false;
    struct eval_hints hints;
    int opnum;
    int critical;
    bool first;
    bool recover;
    int i;

    nasm_static_assert(P_none == 0);

restart_parse:
    first               = true;
    result-&gt;forw_ref    = false;

    stdscan_reset();
    stdscan_set(buffer);
    i = stdscan(NULL, &amp;tokval);

    memset(result-&gt;prefixes, P_none, sizeof(result-&gt;prefixes));
    result-&gt;times       = 1;    /* No TIMES either yet */
    result-&gt;label       = NULL; /* Assume no label */       &lt;-- [2]
    result-&gt;eops        = NULL; /* must do this, whatever happens */
    result-&gt;operands    = 0;    /* must initialize this */
    result-&gt;evex_rm     = 0;    /* Ensure EVEX rounding mode is reset */
    result-&gt;evex_brerop = -1;   /* Reset EVEX broadcasting/ER op position */
</code></pre></div></div>

<p>Here the structureâ€™s member label which should be containing the definition of the label is clearly being assigned to NULL.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    [...]

    if (i == TOKEN_ID || (insn_is_label &amp;&amp; i == TOKEN_INSN)) {    &lt;-- not taken
        /* there's a label here */
        first = false;
        result-&gt;label = tokval.t_charptr;
        i = stdscan(NULL, &amp;tokval);
        if (i == ':') {         /* skip over the optional colon */
            i = stdscan(NULL, &amp;tokval);
        } else if (i == 0) {
            nasm_error(ERR_WARNING | ERR_WARN_OL | ERR_PASS1,
                  "label alone on a line without a colon might be in error");
        }
        if (i != TOKEN_INSN || tokval.t_integer != I_EQU) {
            /*
             * FIXME: location.segment could be NO_SEG, in which case
             * it is possible we should be passing 'absolute.segment'. Look into this.
             * Work out whether that is *really* what we should be doing.
             * Generally fix things. I think this is right as it is, but
             * am still not certain.
             */
            define_label(result-&gt;label,
                         in_absolute ? absolute.segment : location.segment,
                         location.offset, true);
    [...]
</code></pre></div></div>

<p>However, down to a few lines of code, there is a check before the it gets initialized with a valid value which is then skipped because the boolean insn_is_label is always FALSE.
Therefore, the result-&gt;label remains NULL.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    [...]

            /*  forw_ref */
            if (output_ins.opcode == I_EQU) {
                if (!output_ins.label)
                    nasm_error(ERR_NONFATAL,
                               "EQU not preceded by label");

                if (output_ins.operands == 1 &amp;&amp;
                    (output_ins.oprs[0].type &amp; IMMEDIATE) &amp;&amp;
                    output_ins.oprs[0].wrt == NO_SEG) {
                    define_label(output_ins.label,
                                 output_ins.oprs[0].segment,
                                 output_ins.oprs[0].offset, false);   &lt;-- [3]
    [...]
</code></pre></div></div>

<p>So back to the assemble_line, there is a check if the opcode is EQU and surprisingly the nasm_error did not handle the error safely (marked as ERR_NONFATAL).
The output_ins.label is then being passed into 3 functions before it gets dereferenced (define_label -&gt; find_label -&gt; islocal).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static bool islocal(const char *l)
{
    if (tasm_compatible_mode) {
        if (l[0] == '@' &amp;&amp; l[1] == '@')
            return true;
    }
    return (l[0] == '.' &amp;&amp; l[1] != '.');  &lt;-- boom
}
</code></pre></div></div>
<p><br /></p>
